const CACHE_NAME = 'satalign-pro-enterprise-v3.0.0-production';
const APP_VERSION = '3.0.0';
const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

// Resources to cache for offline functionality
const STATIC_RESOURCES = [
  '/',
  '/index.html',
  '/manifest.json'
];

// Dynamic cache patterns
const CACHE_PATTERNS = {
  images: /\.(jpg|jpeg|png|gif|webp|svg|ico)$/i,
  fonts: /\.(woff|woff2|ttf|eot)$/i,
  api: /^https:\/\/api\.satalign\.pro\//,
  telemetry: /^https:\/\/telemetry\.satalign\.pro\//
};

// Professional installation with comprehensive error handling
self.addEventListener('install', function(event) {
  console.log(`üöÄ Installing SatAlign Pro Enterprise Service Worker v${APP_VERSION}`);
  
  event.waitUntil(
    Promise.all([
      // Cache static resources
      caches.open(CACHE_NAME).then(cache => {
        console.log('üì¶ Caching static resources');
        return cache.addAll(STATIC_RESOURCES);
      }),
      
      // Skip waiting to activate immediately
      self.skipWaiting()
    ]).then(() => {
      console.log('‚úÖ Service Worker installation completed');
      
      // Notify clients about successful installation
      return broadcastToClients({
        type: 'SW_INSTALLED',
        version: APP_VERSION,
        timestamp: new Date().toISOString()
      });
    }).catch(error => {
      console.error('‚ùå Service Worker installation failed:', error);
      throw error;
    })
  );
});

// Enhanced activation with client communication and cleanup
self.addEventListener('activate', function(event) {
  console.log(`üîÑ Activating SatAlign Pro Enterprise Service Worker v${APP_VERSION}`);
  
  event.waitUntil(
    Promise.all([
      // Clean up old caches
      cleanupOldCaches(),
      
      // Take control of all clients
      self.clients.claim(),
      
      // Initialize application state
      initializeAppState()
      
    ]).then(() => {
      console.log('‚úÖ Service Worker activation completed');
      
      // Notify all clients about the activation
      return broadcastToClients({
        type: 'SW_ACTIVATED',
        version: APP_VERSION,
        timestamp: new Date().toISOString(),
        features: getAppFeatures()
      });
    }).catch(error => {
      console.error('‚ùå Service Worker activation failed:', error);
    })
  );
});

// Intelligent fetch handling with advanced caching strategies
self.addEventListener('fetch', function(event) {
  const request = event.request;
  const url = new URL(request.url);
  
  // Skip non-GET requests and cross-origin requests (except for specific APIs)
  if (request.method !== 'GET' || (!isOriginAllowed(url) && !isApiRequest(url))) {
    return;
  }

  // Determine cache strategy based on request type
  const strategy = getCacheStrategy(request);
  
  event.respondWith(
    executeStrategy(strategy, request).catch(error => {
      console.error(`Fetch failed for ${request.url}:`, error);
      return handleFetchError(request, error);
    })
  );
});

// Cache strategy determination
function getCacheStrategy(request) {
  const url = new URL(request.url);
  
  // API requests - Network first with cache fallback
  if (CACHE_PATTERNS.api.test(url.href)) {
    return 'network-first';
  }
  
  // Telemetry - Network only (no cache)
  if (CACHE_PATTERNS.telemetry.test(url.href)) {
    return 'network-only';
  }
  
  // Images - Cache first with network fallback
  if (CACHE_PATTERNS.images.test(url.pathname)) {
    return 'cache-first';
  }
  
  // Fonts - Cache first (long-term cache)
  if (CACHE_PATTERNS.fonts.test(url.pathname)) {
    return 'cache-first';
  }
  
  // Main document - Stale while revalidate
  if (request.destination === 'document') {
    return 'stale-while-revalidate';
  }
  
  // Default strategy
  return 'cache-first';
}

// Strategy execution
async function executeStrategy(strategy, request) {
  const cache = await caches.open(CACHE_NAME);
  
  switch (strategy) {
    case 'network-first':
      return networkFirst(cache, request);
    
    case 'cache-first':
      return cacheFirst(cache, request);
    
    case 'stale-while-revalidate':
      return staleWhileRevalidate(cache, request);
    
    case 'network-only':
      return fetch(request);
    
    default:
      return cacheFirst(cache, request);
  }
}

// Network first strategy
async function networkFirst(cache, request) {
  try {
    const response = await fetchAndCache(cache, request);
    return response;
  } catch (error) {
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      console.log(`üì¶ Serving cached response for ${request.url}`);
      return cachedResponse;
    }
    throw error;
  }
}

// Cache first strategy
async function cacheFirst(cache, request) {
  const cachedResponse = await cache.match(request);
  if (cachedResponse && !isExpired(cachedResponse)) {
    return cachedResponse;
  }
  
  try {
    return await fetchAndCache(cache, request);
  } catch (error) {
    if (cachedResponse) {
      console.log(`üì¶ Serving expired cache for ${request.url}`);
      return cachedResponse;
    }
    throw error;
  }
}

// Stale while revalidate strategy
async function staleWhileRevalidate(cache, request) {
  const cachedResponse = await cache.match(request);
  
  // Always try to fetch in the background
  const fetchPromise = fetchAndCache(cache, request).catch(error => {
    console.warn(`Background fetch failed for ${request.url}:`, error);
  });
  
  if (cachedResponse) {
    // Return cached version immediately and update in background
    return cachedResponse;
  } else {
    // Wait for network if no cache available
    return fetchPromise;
  }
}

// Enhanced fetch and cache function
async function fetchAndCache(cache, request) {
  const response = await fetch(request);
  
  // Only cache successful responses
  if (response.status === 200) {
    const responseToCache = response.clone();
    
    // Add timestamp for expiry checking
    const headers = new Headers(responseToCache.headers);
    headers.set('sw-cached-time', Date.now().toString());
    
    const modifiedResponse = new Response(responseToCache.body, {
      status: responseToCache.status,
      statusText: responseToCache.statusText,
      headers: headers
    });
    
    await cache.put(request, modifiedResponse);
  }
  
  return response;
}

// Cache expiry checking
function isExpired(response) {
  const cachedTime = response.headers.get('sw-cached-time');
  if (!cachedTime) return false;
  
  return (Date.now() - parseInt(cachedTime)) > CACHE_EXPIRY;
}

// Error handling for failed fetches
function handleFetchError(request, error) {
  // For HTML documents, try to serve a cached fallback
  if (request.destination === 'document') {
    return caches.match('/index.html').then(response => {
      if (response) {
        return response;
      }
      
      // Return a basic offline page
      return new Response(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>SatAlign Pro - Offline</title>
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <style>
            body { 
              font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
              text-align: center; 
              padding: 50px 20px; 
              background: #0f0f0f; 
              color: white; 
            }
            .logo { font-size: 48px; margin-bottom: 20px; }
            .message { font-size: 18px; margin-bottom: 20px; }
            .details { font-size: 14px; color: #888; }
          </style>
        </head>
        <body>
          <div class="logo">üõ∞Ô∏è</div>
          <h1>SatAlign Pro Enterprise</h1>
          <div class="message">You're currently offline</div>
          <div class="details">Please check your internet connection and try again</div>
        </body>
        </html>
      `, {
        status: 503,
        statusText: 'Service Unavailable',
        headers: {
          'Content-Type': 'text/html'
        }
      });
    });
  }
  
  // For other resources, return a generic error response
  return new Response(JSON.stringify({
    error: 'Network unavailable',
    message: 'This resource is not available offline',
    timestamp: new Date().toISOString()
  }), {
    status: 503,
    statusText: 'Service Unavailable',
    headers: {
      'Content-Type': 'application/json'
    }
  });
}

// Professional message handling
self.addEventListener('message', function(event) {
  const { type, data } = event.data || {};
  
  handleMessage(type, data, event).catch(error => {
    console.error(`Message handling failed for ${type}:`, error);
  });
});

async function handleMessage(type, data, event) {
  switch (type) {
    case 'SKIP_WAITING':
      await self.skipWaiting();
      break;
      
    case 'GET_VERSION':
      respondToClient(event, {
        type: 'VERSION_INFO',
        version: APP_VERSION,
        cache: CACHE_NAME,
        timestamp: new Date().toISOString(),
        features: getAppFeatures()
      });
      break;
      
    case 'GET_CACHE_STATUS':
      const status = await getCacheStatus();
      respondToClient(event, {
        type: 'CACHE_STATUS',
        ...status
      });
      break;
      
    case 'CLEAR_CACHE':
      const success = await clearApplicationCaches();
      respondToClient(event, {
        type: 'CACHE_CLEARED',
        success,
        timestamp: new Date().toISOString()
      });
      break;
      
    case 'SYNC_SATELLITE_DATA':
      await syncSatelliteData(data);
      respondToClient(event, {
        type: 'SATELLITE_DATA_SYNCED',
        timestamp: new Date().toISOString()
      });
      break;
      
    case 'LOG_USAGE':
      await logUsageData(data);
      break;
      
    default:
      console.warn(`Unknown message type: ${type}`);
  }
}

// Background sync handling
self.addEventListener('sync', function(event) {
  console.log(`üîÑ Background sync triggered: ${event.tag}`);
  
  switch (event.tag) {
    case 'satellite-data-sync':
      event.waitUntil(syncSatelliteData());
      break;
      
    case 'telemetry-sync':
      event.waitUntil(syncTelemetryData());
      break;
      
    case 'cache-cleanup':
      event.waitUntil(performCacheCleanup());
      break;
      
    default:
      console.warn(`Unknown sync tag: ${event.tag}`);
  }
});

// Professional push notification handling
self.addEventListener('push', function(event) {
  console.log('üì¨ Push notification received');
  
  let notificationData = {
    title: 'SatAlign Pro Enterprise',
    body: 'New satellite data available',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    tag: 'satellite-update',
    requireInteraction: false,
    vibrate: [200, 100, 200],
    data: {
      url: '/',
      timestamp: Date.now()
    }
  };

  // Parse push data if available
  if (event.data) {
    try {
      const pushData = event.data.json();
      notificationData = { ...notificationData, ...pushData };
    } catch (error) {
      console.error('Failed to parse push data:', error);
    }
  }

  const options = {
    body: notificationData.body,
    icon: notificationData.icon,
    badge: notificationData.badge,
    vibrate: notificationData.vibrate,
    tag: notificationData.tag,
    requireInteraction: notificationData.requireInteraction,
    data: notificationData.data,
    actions: [
      {
        action: 'open',
        title: 'Open App',
        icon: '/icons/action-open.png'
      },
      {
        action: 'dismiss',
        title: 'Dismiss',
        icon: '/icons/action-dismiss.png'
      }
    ]
  };

  event.waitUntil(
    self.registration.showNotification(notificationData.title, options)
  );
});

// Notification click handling
self.addEventListener('notificationclick', function(event) {
  console.log(`üîî Notification clicked: ${event.action}`);
  
  event.notification.close();

  if (event.action === 'dismiss') {
    return;
  }

  const urlToOpen = event.notification.data?.url || '/';

  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then(function(clientList) {
        // Try to focus existing window
        for (const client of clientList) {
          if (client.url.includes(self.location.origin) && 'focus' in client) {
            return client.focus();
          }
        }
        
        // Open new window if none found
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
  );
});

// Utility functions
async function cleanupOldCaches() {
  const cacheNames = await caches.keys();
  const oldCaches = cacheNames.filter(name => 
    name.startsWith('satalign-pro') && name !== CACHE_NAME
  );
  
  const deletePromises = oldCaches.map(name => {
    console.log(`üóëÔ∏è Deleting old cache: ${name}`);
    return caches.delete(name);
  });
  
  await Promise.all(deletePromises);
  console.log(`‚úÖ Cleaned up ${oldCaches.length} old caches`);
}

async function initializeAppState() {
  // Initialize any required application state
  console.log('üîß Initializing application state');
  
  // Could include setting up IndexedDB, checking for updates, etc.
}

function isOriginAllowed(url) {
  return url.origin === self.location.origin;
}

function isApiRequest(url) {
  return CACHE_PATTERNS.api.test(url.href) || CACHE_PATTERNS.telemetry.test(url.href);
}

async function broadcastToClients(message) {
  const clients = await self.clients.matchAll();
  clients.forEach(client => {
    client.postMessage(message);
  });
}

function respondToClient(event, response) {
  if (event.ports && event.ports[0]) {
    event.ports[0].postMessage(response);
  }
}

async function getCacheStatus() {
  try {
    const cacheNames = await caches.keys();
    const appCaches = cacheNames.filter(name => name.startsWith('satalign-pro'));
    
    const cacheDetails = await Promise.all(
      appCaches.map(async name => {
        const cache = await caches.open(name);
        const keys = await cache.keys();
        return {
          name,
          size: keys.length,
          current: name === CACHE_NAME
        };
      })
    );
    
    return {
      totalCaches: appCaches.length,
      currentCache: CACHE_NAME,
      caches: cacheDetails,
      version: APP_VERSION
    };
  } catch (error) {
    console.error('Failed to get cache status:', error);
    return { error: error.message };
  }
}

async function clearApplicationCaches() {
  try {
    const cacheNames = await caches.keys();
    const appCaches = cacheNames.filter(name => name.startsWith('satalign-pro'));
    
    const deletePromises = appCaches.map(name => caches.delete(name));
    await Promise.all(deletePromises);
    
    console.log(`üßπ Cleared ${appCaches.length} application caches`);
    return true;
  } catch (error) {
    console.error('Failed to clear caches:', error);
    return false;
  }
}

async function syncSatelliteData(data) {
  try {
    console.log('üõ∞Ô∏è Syncing satellite data...');
    
    if (data && data.satellites) {
      const cache = await caches.open(CACHE_NAME);
      const response = new Response(JSON.stringify(data), {
        headers: {
          'Content-Type': 'application/json',
          'sw-cached-time': Date.now().toString()
        }
      });
      await cache.put('/satellite-data.json', response);
    }
    
    await broadcastToClients({
      type: 'SATELLITE_DATA_UPDATED',
      timestamp: new Date().toISOString()
    });
    
    console.log('‚úÖ Satellite data sync completed');
  } catch (error) {
    console.error('‚ùå Satellite data sync failed:', error);
  }
}

async function syncTelemetryData() {
  try {
    console.log('üìä Syncing telemetry data...');
    
    // Implementation would depend on telemetry requirements
    // This would typically send queued analytics data
    
    console.log('‚úÖ Telemetry sync completed');
  } catch (error) {
    console.error('‚ùå Telemetry sync failed:', error);
  }
}

async function performCacheCleanup() {
  try {
    console.log('üßπ Performing cache cleanup...');
    
    const cache = await caches.open(CACHE_NAME);
    const requests = await cache.keys();
    
    // Remove expired entries
    const expiredRequests = [];
    for (const request of requests) {
      const response = await cache.match(request);
      if (response && isExpired(response)) {
        expiredRequests.push(request);
      }
    }
    
    const deletePromises = expiredRequests.map(request => cache.delete(request));
    await Promise.all(deletePromises);
    
    console.log(`‚úÖ Cache cleanup completed, removed ${expiredRequests.length} expired entries`);
  } catch (error) {
    console.error('‚ùå Cache cleanup failed:', error);
  }
}

async function logUsageData(data) {
  try {
    // Store usage data for later sync
    // Implementation would depend on privacy requirements
    console.log('üìä Usage data logged');
  } catch (error) {
    console.error('Failed to log usage data:', error);
  }
}

function getAppFeatures() {
  return [
    'Professional Satellite Alignment',
    'Enterprise-grade Precision',
    'Cross-platform Support',
    'AR Guidance System',
    'Multi-language Interface',
    'Offline Capability',
    'Real-time Updates',
    'Professional Compass',
    'Advanced Calculations',
    'Secure Data Handling'
  ];
}

// Error handling
self.addEventListener('error', function(event) {
  console.error('üö® Service Worker error:', event.error);
  
  broadcastToClients({
    type: 'SW_ERROR',
    error: event.error.message,
    timestamp: new Date().toISOString()
  });
});

self.addEventListener('unhandledrejection', function(event) {
  console.error('üö® Unhandled promise rejection in SW:', event.reason);
  event.preventDefault();
  
  broadcastToClients({
    type: 'SW_ERROR',
    error: 'Unhandled promise rejection',
    details: event.reason?.message || String(event.reason),
    timestamp: new Date().toISOString()
  });
});

// Periodic maintenance
function schedulePeriodicMaintenance() {
  setInterval(() => {
    performCacheCleanup();
  }, 6 * 60 * 60 * 1000); // Every 6 hours
}

// Professional startup logging
console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë               SatAlign Pro Enterprise                     ‚ïë
‚ïë            Production Service Worker v${APP_VERSION}                ‚ïë
‚ïë                                                           ‚ïë
‚ïë  üõ∞Ô∏è  Professional Satellite Alignment System             ‚ïë
‚ïë  üåç  Multi-platform Support (iOS/Android/Desktop)        ‚ïë
‚ïë  üì±  Progressive Web Application                          ‚ïë
‚ïë  üîí  Enterprise Security & Privacy                       ‚ïë
‚ïë  ‚ö°  Optimized Performance & Caching                     ‚ïë
‚ïë  üéØ  Advanced AR Guidance                                ‚ïë
‚ïë                                                           ‚ïë
‚ïë  Cache: ${CACHE_NAME}    ‚ïë
‚ïë  Started: ${new Date().toISOString()}                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

// Initialize maintenance schedule
schedulePeriodicMaintenance();

// Export service worker information for debugging
self.SW_INFO = {
  name: 'SatAlign Pro Enterprise',
  version: APP_VERSION,
  cache: CACHE_NAME,
  startupTime: new Date().toISOString(),
  features: getAppFeatures(),
  cacheStrategy: 'intelligent-multi-tier',
  supportedPlatforms: ['iOS', 'Android', 'Desktop'],
  securityLevel: 'Enterprise'
};
const urlsToCache = [
  '/',
  '/index.html',
  '/manifest.json'
];

// ÿ™ÿ´ÿ®Ÿäÿ™ ÿßÿ≠ÿ™ÿ±ÿßŸÅŸä ŸÖÿπ ŸÖÿπÿßŸÑÿ¨ÿ© ŸÖÿ≠ÿ≥ŸÜÿ© ŸÑŸÑÿ£ÿÆÿ∑ÿßÿ°
self.addEventListener('install', function(event) {
  console.log('üöÄ ÿ™ÿ´ÿ®Ÿäÿ™ SatAlign Pro Enterprise Service Worker v3.0.0');
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(function(cache) {
        console.log('üì¶ ŸÅÿ™ÿ≠ ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™:', CACHE_NAME);
        return cache.addAll(urlsToCache);
      })
      .then(() => {
        console.log('‚úÖ ÿ™ŸÖ ŸÖŸÑÿ° ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™ ÿ®ŸÜÿ¨ÿßÿ≠');
        return self.skipWaiting();
      })
      .catch(error => {
        console.error('‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ŸÖŸÑÿ° ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™:', error);
        throw error;
      })
  );
});

// ÿ™ŸÅÿπŸäŸÑ ŸÖÿ≠ÿ≥ŸÜ ŸÖÿπ ÿ™ŸàÿßÿµŸÑ ÿßŸÑÿπŸÖŸäŸÑ
self.addEventListener('activate', function(event) {
  console.log('üîÑ ÿ™ŸÅÿπŸäŸÑ SatAlign Pro Enterprise Service Worker');
  event.waitUntil(
    Promise.all([
      // ÿ™ŸÜÿ∏ŸäŸÅ ÿ∞ÿßŸÉÿ±ÿßÿ™ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÇÿØŸäŸÖÿ©
      caches.keys().then(function(cacheNames) {
        return Promise.all(
          cacheNames.map(function(cacheName) {
            if (cacheName !== CACHE_NAME && cacheName.startsWith('satalign-pro')) {
              console.log('üóëÔ∏è ÿ≠ÿ∞ŸÅ ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÇÿØŸäŸÖÿ©:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      }),
      // ÿßŸÑÿ≥Ÿäÿ∑ÿ±ÿ© ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÖŸÑÿßÿ°
      self.clients.claim()
    ]).then(() => {
      // ÿ•ÿ¥ÿπÿßÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÖŸÑÿßÿ° ÿ®ÿßŸÑÿ™ÿ≠ÿØŸäÿ´
      return self.clients.matchAll().then(clients => {
        clients.forEach(client => {
          client.postMessage({
            type: 'SW_UPDATED',
            message: 'ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ SatAlign Pro Enterprise ÿ•ŸÑŸâ ÿ£ÿ≠ÿØÿ´ ÿ•ÿµÿØÿßÿ±',
            version: CACHE_NAME,
            timestamp: new Date().toISOString()
          });
        });
      });
    }).then(() => {
      console.log('‚úÖ ÿßŸÉÿ™ŸÖŸÑ ÿ™ŸÅÿπŸäŸÑ Service Worker');
    }).catch(error => {
      console.error('‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ŸÅÿπŸäŸÑ Service Worker:', error);
    })
  );
});

// ŸÖÿπÿßŸÑÿ¨ÿ© ÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ© ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™ ŸÖÿπ ÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿßÿ™ ÿ™ÿÆÿ≤ŸäŸÜ ÿ∞ŸÉŸäÿ©
self.addEventListener('fetch', function(event) {
  // ÿ™ÿÆÿ∑Ÿä ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿ∫Ÿäÿ± GET
  if (event.request.method !== 'GET') {
    return;
  }

  // ÿ™ÿÆÿ∑Ÿä ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿπÿ®ÿ± ÿßŸÑŸÜÿ∑ÿßŸÇÿßÿ™
  if (!event.request.url.startsWith(self.location.origin)) {
    return;
  }

  event.respondWith(
    caches.match(event.request)
      .then(function(cachedResponse) {
        // ÿ•ÿ±ÿ¨ÿßÿπ ÿßŸÑŸÜÿ≥ÿÆÿ© ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ© ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÖÿ™ŸàŸÅÿ±ÿ©
        if (cachedResponse) {
          // ŸÑŸÑŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ HTMLÿå ŸÅÿ≠ÿµ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ŸÅŸä ÿßŸÑÿÆŸÑŸÅŸäÿ©
          if (event.request.destination === 'document') {
            fetchAndCache(event.request);
          }
          return cachedResponse;
        }
        
        // ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ ŸÅŸä ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜÿå ÿ¨ŸÑÿ® ŸÖŸÜ ÿßŸÑÿ¥ÿ®ŸÉÿ©
        return fetchAndCache(event.request);
      })
      .catch(() => {
        // ŸÅÿ¥ŸÑÿ™ ÿßŸÑÿ¥ÿ®ŸÉÿ© Ÿàÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™
        if (event.request.destination === 'document') {
          return caches.match('/index.html');
        }
        
        // ŸÑŸÑŸÖŸàÿßÿ±ÿØ ÿßŸÑÿ£ÿÆÿ±Ÿâÿå ÿ•ÿ±ÿ¨ÿßÿπ ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿπÿßŸÖÿ© ŸÑŸÑŸàÿ∂ÿπ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ™ÿµŸÑ
        return new Response('ÿ∫Ÿäÿ± ŸÖÿ™ÿµŸÑ - SatAlign Pro Enterprise', {
          status: 503,
          statusText: 'ÿßŸÑÿÆÿØŸÖÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©',
          headers: new Headers({
            'Content-Type': 'text/plain; charset=utf-8'
          })
        });
      })
  );
});

// ÿØÿßŸÑÿ© ÿ¨ŸÑÿ® Ÿàÿ™ÿÆÿ≤ŸäŸÜ ŸÖÿ≠ÿ≥ŸÜÿ©
async function fetchAndCache(request) {
  try {
    const response = await fetch(request);
    
    // ŸÅÿ≠ÿµ ÿµÿ≠ÿ© ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©
    if (!response || response.status !== 200 || response.type !== 'basic') {
      return response;
    }

    // ŸÜÿ≥ÿÆ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ŸÑŸÑÿ™ÿÆÿ≤ŸäŸÜ
    const responseToCache = response.clone();

    // ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ©
    const cache = await caches.open(CACHE_NAME);
    await cache.put(request, responseToCache);
    
    return response;
  } catch (error) {
    console.error('ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑÿ¨ŸÑÿ®:', error);
    throw error;
  }
}

// ŸÖÿπÿßŸÑÿ¨ÿ© ÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ© ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ
self.addEventListener('message', function(event) {
  const { type, data } = event.data || {};
  
  switch (type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;
      
    case 'GET_VERSION':
      event.ports[0].postMessage({
        type: 'VERSION_INFO',
        version: CACHE_NAME,
        timestamp: new Date().toISOString(),
        features: [
          'ÿ∂ÿ®ÿ∑ ÿßÿ≠ÿ™ÿ±ÿßŸÅŸä ŸÑŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ©',
          'ÿØÿπŸÖ ŸÖÿ™ÿπÿØÿØ ÿßŸÑŸÑÿ∫ÿßÿ™',
          'ŸÜÿ∏ÿßŸÖ ÿ™Ÿàÿ¨ŸäŸá ÿßŸÑŸàÿßŸÇÿπ ÿßŸÑŸÖÿπÿ≤ÿ≤',
          'ÿØŸÇÿ© ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÖÿ§ÿ≥ÿ≥ÿßÿ™',
          'ŸÇÿØÿ±ÿ© ÿßŸÑÿπŸÖŸÑ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ™ÿµŸÑ'
        ]
      });
      break;
      
    case 'GET_CACHE_STATUS':
      getCacheStatus().then(status => {
        event.ports[0].postMessage({
          type: 'CACHE_STATUS',
          ...status
        });
      });
      break;
      
    case 'CLEAR_CACHE':
      clearAllCaches().then(result => {
        event.ports[0].postMessage({
          type: 'CACHE_CLEARED',
          success: result
        });
      });
      break;

    case 'UPDATE_SATELLITE_DATA':
      updateSatelliteData(data).then(result => {
        event.ports[0].postMessage({
          type: 'SATELLITE_DATA_UPDATED',
          success: result
        });
      });
      break;
      
    default:
      console.log('ŸÜŸàÿπ ÿ±ÿ≥ÿßŸÑÿ© ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ:', type);
  }
});

// ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ≠ÿßŸÑÿ© ÿ¥ÿßŸÖŸÑÿ© ŸÑÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™
async function getCacheStatus() {
  try {
    const cacheNames = await caches.keys();
    const cacheDetails = await Promise.all(
      cacheNames.map(async name => {
        const cache = await caches.open(name);
        const keys = await cache.keys();
        return {
          name,
          size: keys.length,
          urls: keys.map(request => request.url)
        };
      })
    );
    
    return {
      totalCaches: cacheNames.length,
      currentCache: CACHE_NAME,
      caches: cacheDetails
    };
  } catch (error) {
    console.error('ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ≠ÿßŸÑÿ© ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™:', error);
    return { error: error.message };
  }
}

// ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿ∞ÿßŸÉÿ±ÿßÿ™ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™ ŸÑŸÑÿ™ÿ∑ÿ®ŸäŸÇ
async function clearAllCaches() {
  try {
    const cacheNames = await caches.keys();
    const deletePromises = cacheNames
      .filter(name => name.startsWith('satalign-pro'))
      .map(name => caches.delete(name));
    
    await Promise.all(deletePromises);
    console.log('üßπ ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿ∞ÿßŸÉÿ±ÿßÿ™ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™ ÿ®ŸÜÿ¨ÿßÿ≠');
    return true;
  } catch (error) {
    console.error('ŸÅÿ¥ŸÑ ŸÅŸä ŸÖÿ≥ÿ≠ ÿ∞ÿßŸÉÿ±ÿßÿ™ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™:', error);
    return false;
  }
}

// ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ©
async function updateSatelliteData(data) {
  try {
    console.log('üõ∞Ô∏è ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ©...');
    
    // ŸáŸÜÿß ŸäŸÖŸÉŸÜ ÿ•ÿ∂ÿßŸÅÿ© ŸÖŸÜÿ∑ŸÇ ÿ≠ŸÅÿ∏ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿ¨ÿØŸäÿØÿ©
    const cache = await caches.open(CACHE_NAME);
    
    if (data && data.satellites) {
      // ÿ≠ŸÅÿ∏ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØÿ© ŸÅŸä ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™
      const response = new Response(JSON.stringify(data), {
        headers: {
          'Content-Type': 'application/json'
        }
      });
      await cache.put('/satellite-data.json', response);
    }
    
    const timestamp = new Date().toISOString();
    console.log('‚úÖ ÿßŸÉÿ™ŸÖŸÑ ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ© ŸÅŸä:', timestamp);
    
    // ÿ•ÿ¥ÿπÿßÿ± ÿßŸÑÿπŸÖŸÑÿßÿ° ÿ®ÿßŸÑÿ™ÿ≠ÿØŸäÿ´
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'SATELLITE_DATA_UPDATED',
        timestamp
      });
    });

    return true;
  } catch (error) {
    console.error('‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ©:', error);
    return false;
  }
}

// ŸÖÿ≤ÿßŸÖŸÜÿ© ÿÆŸÑŸÅŸäÿ© ÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ© ŸÑÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
self.addEventListener('sync', function(event) {
  console.log('üîÑ ÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ŸÖÿ≤ÿßŸÖŸÜÿ© ÿßŸÑÿÆŸÑŸÅŸäÿ©:', event.tag);
  
  switch (event.tag) {
    case 'satellite-data-sync':
      event.waitUntil(syncSatelliteData());
      break;
      
    case 'usage-analytics':
      event.waitUntil(syncUsageAnalytics());
      break;

    case 'location-update':
      event.waitUntil(syncLocationData());
      break;
      
    default:
      console.log('ÿπŸÑÿßŸÖÿ© ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅÿ©:', event.tag);
  }
});

// ŸÖÿ≤ÿßŸÖŸÜÿ© ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ©
async function syncSatelliteData() {
  try {
    console.log('üõ∞Ô∏è ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ©...');
    
    // Ÿáÿ∞ÿß ÿßŸÑŸÖŸÉÿßŸÜ ŸäŸÖŸÉŸÜ ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÖŸÜÿ∑ŸÇ ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ≠ÿØÿ´ÿ© ŸÖŸÜ ÿßŸÑÿÆÿßÿØŸÖ
    // ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿå ÿ≥ŸÜŸÇŸàŸÖ ÿ®ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÅŸÇÿ∑
    const timestamp = new Date().toISOString();
    console.log('‚úÖ ÿßŸÉÿ™ŸÖŸÑÿ™ ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ© ŸÅŸä:', timestamp);
    
    // ÿ•ÿ¥ÿπÿßÿ± ÿßŸÑÿπŸÖŸÑÿßÿ° ÿ®ÿßŸÑÿ™ÿ≠ÿØŸäÿ´
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'SATELLITE_DATA_SYNCED',
        timestamp
      });
    });
  } catch (error) {
    console.error('‚ùå ŸÅÿ¥ŸÑÿ™ ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ©:', error);
  }
}

// ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ™ÿ≠ŸÑŸäŸÑÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ (ŸÖÿπ ŸÖÿ±ÿßÿπÿßÿ© ÿßŸÑÿÆÿµŸàÿµŸäÿ©)
async function syncUsageAnalytics() {
  try {
    console.log('üìä ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ™ÿ≠ŸÑŸäŸÑÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ...');
    
    // Ÿáÿ∞ÿß ŸäŸÖŸÉŸÜ ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿ¨ŸáŸàŸÑÿ© ÿßŸÑŸáŸàŸäÿ©
    // ÿ™ŸÜŸÅŸäÿ∞ ÿ∞ŸÑŸÉ Ÿäÿπÿ™ŸÖÿØ ÿπŸÑŸâ ŸÖÿ™ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑÿÆÿµŸàÿµŸäÿ©
    console.log('‚úÖ ÿßŸÉÿ™ŸÖŸÑÿ™ ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ™ÿ≠ŸÑŸäŸÑÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ');
  } catch (error) {
    console.error('‚ùå ŸÅÿ¥ŸÑÿ™ ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ™ÿ≠ŸÑŸäŸÑÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ:', error);
  }
}

// ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ
async function syncLocationData() {
  try {
    console.log('üìç ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ...');
    
    // ŸÖŸÜÿ∑ŸÇ ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ ŸàÿßŸÑÿßŸÜÿ≠ÿ±ÿßŸÅ ÿßŸÑŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥Ÿä
    console.log('‚úÖ ÿßŸÉÿ™ŸÖŸÑÿ™ ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ');
  } catch (error) {
    console.error('‚ùå ŸÅÿ¥ŸÑÿ™ ŸÖÿ≤ÿßŸÖŸÜÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ:', error);
  }
}

// ŸÖÿπÿßŸÑÿ¨ÿ© ÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ© ŸÑŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿ™ÿ≠ŸÅŸäÿ≤Ÿäÿ©
self.addEventListener('push', function(event) {
  console.log('üì¨ ÿ™ŸÖ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ•ÿ¥ÿπÿßÿ± ÿ™ÿ≠ŸÅŸäÿ≤Ÿä');
  
  let notificationData = {
    title: 'SatAlign Pro Enterprise',
    body: 'ÿ®ŸäÿßŸÜÿßÿ™ ÿ£ŸÇŸÖÿßÿ± ÿµŸÜÿßÿπŸäÿ© ÿ¨ÿØŸäÿØÿ© ŸÖÿ™ŸàŸÅÿ±ÿ©',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    tag: 'satellite-update',
    requireInteraction: false,
    vibrate: [100, 50, 100],
    data: {
      url: '/'
    }
  };

  // ÿ™ÿ≠ŸÑŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÖÿ™ŸàŸÅÿ±ÿ©
  if (event.data) {
    try {
      const pushData = event.data.json();
      notificationData = { ...notificationData, ...pushData };
    } catch (error) {
      console.error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±:', error);
    }
  }

  const options = {
    body: notificationData.body,
    icon: notificationData.icon,
    badge: notificationData.badge,
    vibrate: notificationData.vibrate,
    tag: notificationData.tag,
    requireInteraction: notificationData.requireInteraction,
    data: {
      dateOfArrival: Date.now(),
      primaryKey: notificationData.tag,
      url: notificationData.data?.url || '/'
    },
    actions: [
      {
        action: 'open',
        title: 'ŸÅÿ™ÿ≠ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ',
        icon: '/icons/action-open.png'
      },
      {
        action: 'dismiss',
        title: 'ÿ•ÿ∫ŸÑÿßŸÇ',
        icon: '/icons/action-dismiss.png'
      }
    ]
  };

  event.waitUntil(
    self.registration.showNotification(notificationData.title, options)
  );
});

// ŸÖÿπÿßŸÑÿ¨ÿ© ÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ© ŸÑŸÑŸÜŸÇÿ± ÿπŸÑŸâ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
self.addEventListener('notificationclick', function(event) {
  console.log('üîî ÿ™ŸÖ ÿßŸÑŸÜŸÇÿ± ÿπŸÑŸâ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±:', event.action);
  
  event.notification.close();

  if (event.action === 'dismiss') {
    return;
  }

  const urlToOpen = event.notification.data?.url || '/';

  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then(function(clientList) {
        // ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿ™ÿ±ŸÉŸäÿ≤ ÿπŸÑŸâ ŸÜÿßŸÅÿ∞ÿ© ŸÖŸàÿ¨ŸàÿØÿ©
        for (let i = 0; i < clientList.length; i++) {
          const client = clientList[i];
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        
        // ŸÅÿ™ÿ≠ ŸÜÿßŸÅÿ∞ÿ© ÿ¨ÿØŸäÿØÿ© ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™Ÿàÿ¨ÿØ
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
  );
});

// ŸÖÿπÿßŸÑÿ¨ÿ© ŸÖÿ≠ÿ≥ŸÜÿ© ŸÑŸÑÿ£ÿÆÿ∑ÿßÿ° ŸàÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ
self.addEventListener('error', function(event) {
  console.error('üö® ÿÆÿ∑ÿ£ Service Worker:', event.error);
  
  // ÿ•ÿ®ŸÑÿßÿ∫ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑÿ≠ÿ±ÿ¨ÿ© ŸÑŸÑÿπŸÖŸÑÿßÿ°
  self.clients.matchAll().then(clients => {
    clients.forEach(client => {
      client.postMessage({
        type: 'SW_ERROR',
        error: event.error.message,
        timestamp: new Date().toISOString()
      });
    });
  });
});

// ŸÖÿπÿßŸÑÿ¨ÿ© ÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ© ŸÑÿ±ŸÅÿ∂ ÿßŸÑŸàÿπŸàÿØ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©
self.addEventListener('unhandledrejection', function(event) {
  console.error('üö® ÿ±ŸÅÿ∂ ÿ∫Ÿäÿ± ŸÖÿπÿßŸÑÿ¨ ŸÑŸÑŸàÿπÿØ ŸÅŸä SW:', event.reason);
  event.preventDefault();
});

// ÿµŸäÿßŸÜÿ© ÿØŸàÿ±Ÿäÿ© Ÿàÿ™ŸÜÿ∏ŸäŸÅ
function performMaintenance() {
  console.log('üßπ ÿ•ÿ¨ÿ±ÿßÿ° ÿµŸäÿßŸÜÿ© Service Worker...');
  
  // ÿ™ŸÜÿ∏ŸäŸÅ ÿ•ÿØÿÆÿßŸÑÿßÿ™ ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™ ÿßŸÑŸÇÿØŸäŸÖÿ©
  caches.open(CACHE_NAME).then(cache => {
    cache.keys().then(requests => {
      // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ•ÿØÿÆÿßŸÑÿßÿ™ ÿßŸÑÿ™Ÿä ÿπŸÖÿ±Ÿáÿß ÿ£ŸÉÿ´ÿ± ŸÖŸÜ 24 ÿ≥ÿßÿπÿ© (ÿ•ÿ∞ÿß ÿ™ÿ™ÿ®ÿπŸÜÿß ÿßŸÑÿ∑Ÿàÿßÿ®ÿπ ÿßŸÑÿ≤ŸÖŸÜŸäÿ©)
      console.log(`üì¶ ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ§ŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿ© ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ${requests.length} ÿ•ÿØÿÆÿßŸÑ`);
    });
  });
}

// ÿ¨ÿØŸàŸÑÿ© ÿßŸÑÿµŸäÿßŸÜÿ© ŸÉŸÑ 6 ÿ≥ÿßÿπÿßÿ™
setInterval(performMaintenance, 6 * 60 * 60 * 1000);

// ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßÿ≠ÿ™ÿ±ÿßŸÅŸä ŸÑÿ®ÿØÿ° ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ
console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                SatAlign Pro Enterprise                    ‚ïë
‚ïë              Service Worker v3.0.0                       ‚ïë
‚ïë                                                           ‚ïë
‚ïë  üõ∞Ô∏è  ŸÜÿ∏ÿßŸÖ ÿ∂ÿ®ÿ∑ ÿßŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ© ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸä                ‚ïë
‚ïë  üåç  ÿØÿπŸÖ ŸÖÿ™ÿπÿØÿØ ÿßŸÑŸÑÿ∫ÿßÿ™ (ÿπÿ±ÿ®Ÿä/ÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿä)                    ‚ïë
‚ïë  üì±  ÿ™ÿ∑ÿ®ŸäŸÇ ŸàŸäÿ® ÿ™ŸÇÿØŸÖŸä                                     ‚ïë
‚ïë  üîí  ŸÇÿØÿ±ÿ© ÿ¢ŸÖŸÜÿ© ŸÑŸÑÿπŸÖŸÑ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ™ÿµŸÑ                         ‚ïë
‚ïë  ‚ö°  ÿ£ÿØÿßÿ° ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÖÿ§ÿ≥ÿ≥ÿßÿ™                            ‚ïë
‚ïë                                                           ‚ïë
‚ïë  ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ: ${CACHE_NAME}        ‚ïë
‚ïë  ÿ®ÿØÿ° ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ: ${new Date().toISOString()}              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

// ÿ™ÿµÿØŸäÿ± ŸÖÿπŸÑŸàŸÖÿßÿ™ service worker ŸÑŸÑÿ™ÿµÿ≠Ÿäÿ≠
self.SW_INFO = {
  version: CACHE_NAME,
  startupTime: new Date().toISOString(),
  features: [
    'ÿ∂ÿ®ÿ∑ ÿßÿ≠ÿ™ÿ±ÿßŸÅŸä ŸÑŸÑÿ£ŸÇŸÖÿßÿ± ÿßŸÑÿµŸÜÿßÿπŸäÿ©',
    'ŸÜÿ∏ÿßŸÖ ÿ™Ÿàÿ¨ŸäŸá ÿßŸÑŸàÿßŸÇÿπ ÿßŸÑŸÖÿπÿ≤ÿ≤', 
    'ÿØÿπŸÖ ŸÖÿ™ÿπÿØÿØ ÿßŸÑŸÑÿ∫ÿßÿ™',
    'ŸÇÿØÿ±ÿ© ÿßŸÑÿπŸÖŸÑ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ™ÿµŸÑ',
    'ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿ™ÿ≠ŸÅŸäÿ≤Ÿäÿ©',
    'ŸÖÿ≤ÿßŸÖŸÜÿ© ÿßŸÑÿÆŸÑŸÅŸäÿ©',
    'ÿ£ŸÖÿßŸÜ ÿßŸÑŸÖÿ§ÿ≥ÿ≥ÿßÿ™'
  ]
};
